{"tittle": "微信小程序开发需要注意的一些规范 ", "author": "Rolan", "pub_time": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"tittle": "微信小程序--发表评价满意度 ", "author": "Rolan", "pub_time": "2019-5-7 00:46", "content": "话不多说，我们来看一下效果图：要实现的效果：点击到第几颗星，就要显示到第几颗星,接下来直接查看源码：<view class=\"l-evalbox row\">    <text class=\"l-evaltxt\">满意度：</text>    <view class=\"l-evalist flex-1\" bindtap=\"chooseicon\">        <icon class=\"{{tabArr.curHdIndex >'0'? 'cur icon' : 'icon'}}\" data-id=\"1\"></icon>        <icon class=\"{{tabArr.curHdIndex >'1'? 'cur icon' : 'icon'}}\" data-id=\"2\"></icon>        <icon class=\"{{tabArr.curHdIndex >'2'? 'cur icon' : 'icon'}}\" data-id=\"3\"></icon>        <icon class=\"{{tabArr.curHdIndex >'3'? 'cur icon' : 'icon'}}\" data-id=\"4\"></icon>        <icon class=\"{{tabArr.curHdIndex >'4'? 'cur icon' : 'icon'}}\" data-id=\"5\"></icon>    </view></view>css如下：.l-evalbox{    height: 100rpx;    padding: 0 3%;    margin-top: 10rpx;    background: #FFF;    line-height: 100rpx;}.l-evaltxt{    width: 120rpx;    display: block;    font-size: 26rpx;    color: #666666;}.l-evalist .icon{    background-position:  -77rpx -246rpx;    width: 40rpx;    height: 43rpx;    margin-right: 30rpx;}.l-evalist .cur{    background-position:  -128rpx -246rpx;}.l-evalist .icon:last-child{    margin: 0;}js代码如下：chooseicon:function(e){    var strnumber=e.target.dataset.id;       var _obj={};        _obj.curHdIndex=strnumber;         this.setData({           tabArr: _obj        });  },这样效果显示如下："}
{"tittle": "微信小程序之数据访问 ", "author": "Rolan", "pub_time": "2019-5-7 00:56", "content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的--------------------------------------------华丽的分割线--------------------------------------------------------数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。 我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了，容后再议。"}
{"tittle": "小程序富文本解析的「伪需求」，从wxParse到towxml的坑 ", "author": "Rolan", "pub_time": "2019-5-9 00:48", "content": "本文主要谈谈小程序的富文本解析和目前我的博客小程序用到的两款开源组件 wxParse 和 towxml富文本「伪需求」在进入正题之前想先聊聊「伪需求」这三个字。其实有很多场景会用到富文本框「通常后台维护一长串html文本，前台进行渲染展示」。但由于小程序的一些特殊性，无法直接渲染html，因此类似 wxParse 的开源组件诞生了「原理无非是穷举标签进行替换，差异在于覆盖是否全面和是否更加高效」在小程序刚出来的时候，富文本的问题也一直被吐槽，直到 web-view 的出现「承载网页的容器。会自动铺满整个小程序页面」。小程序终于可以「直接」渲染网页了，很多公司也利用这一点，很多页面都直接采用H5的方式开发，嵌套进小程序中。然而比较悲催的是 web-view 有个限制：个人类型与海外类型的小程序暂不支持使用。所以对于个人开发的小程序来说，依旧需要依赖类似 wxParse 的开源组件。wxParse还是towxml在基于 ghost 的博客小程序中，我用的是 wxParse ，截止到发文该项目已有6071个star，很多教程也是基于 wxParse 的，但作者似乎已经弃坑了，两年多没有再进行迭代了，所以该组件也存在很多问题。自己的项目也是在 wxParse 基础之上进行了很多改动。所以在开发新版的小程序时候果断找个替换它，可惜的是目前这类的开源组件不多「比较小众吧，只有个人开发者才会用吧」，比较之后发现还是 towxml 最佳。首先解析比较全面，样式也比较完美，对于公众号花哨的排版基本支持「只能是基本，后面会说到坑」。另外一点支持服务端解析「云函数可以利用起来」。唯一遗憾的是，体积还是比较大的，后面功能完善后打算看下它的源码进行相应的瘦身。如何使用towxml使用 towxml 还是比较简单的，网上有很多教程，这里简单说下基于服务端解析、小程序端直接渲染的方式：首先下载源码，将 towxml 整个文件夹放到小程序的根目录下。然后在 app.js 中引入并初始化：const Towxml = require('/towxml/main'); \r\nApp({           \r\n  onLaunch: function () {\r\n    ...\r\n  },\r\n  towxml:new Towxml(),\r\n  checkUserInfo: function(cb) {\r\n    ...\r\n  },\r\n  globalData: {\r\n    openid: \"\",\r\n    userInfo: null\r\n  }\r\n})接着在需要使用的地方引入模板，比如我的 detail.wxml 下：<import src=\"/towxml/entry.wxml\" />\r\n//post.content是解析后的文本\r\n<template is=\"entry\" data=\"{{...post.content}}\" />在云函数端，首先安装 towxml :npm install towxml然后申明后直接进项解析，代码如下：/**\r\n * 获取文章明细\r\n * @param {} id \r\n */\r\nasync function getPostsDetail(event) {\r\n  let post = await db.collection(\"mini_posts\").doc(event.id).get()\r\n  if (post.code) {\r\n    return \"\";\r\n  }\r\n  if (!post.data) {\r\n    return \"\";\r\n  }\r\n\r\n  let content = await convertPosts(post.data.content, \"html\");\r\n  //直接赋值towxml解析后的文本\r\n  post.data.content = content;\r\n  console.info(result)\r\n  return post.data\r\n}\r\n\r\n/**\r\n * 转换下程序文章\r\n * @param {} isUpdate \r\n */\r\nasync function convertPosts(content, type) {\r\n  let res\r\n  if (type === 'markdown') {\r\n    res = await towxml.toJson(content || '', 'markdown');\r\n  } else {\r\n    res = await towxml.toJson(content || '', 'html');\r\n  }\r\n  return res;\r\n\r\n}到这里，文章应该可以正常渲染了，使用起来相对还是比较简单的。towxml的坑准确来说是公众号文章的html一些特殊性和复杂性，导致在解析渲染的时候样式上存在一些问题。首先遇到的问题，图片展示不了，如下截图：在查看解析后的文本json后发现， img 的 src 属性是空的。再回过头看公众号文章原始的 html 的时候发现，原始的 img 标签下的属性都是 data-src 开始的，难怪无法解析。<img class=\"\"\r\ndata-ratio=\"2.1638888888888888\" data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/ibT18LpyNmXqYXfbcbQ7N4kIeJYWSEzDHMDwmbNMUBvaRP7U2zwib9ladYZ2v5mZ1rLRFP2NnCtEuPzs3ibrsKqGQ/640?wx_fmt=jpeg\"\r\ndata-type=\"jpeg\" data-w=\"1080\"title=\"image\">水平不够无法改 towxml 的源码，只能在同步文章的时候做下手脚,将 data-src 替换成 src//替换图片data-url\r\ncontent=content.replace(/data-src/g,\"src\")然后发现公众号自带的代码片段样式解析之后也存在问题，截图如下,在代码上方多了很多点。有了图片不展示的经验，就比较容易定位问题了，应该是towxml在解析代码序号的时候生成 ul 和 li 标签了，但在样式上没有做好处理。<ul class=\"code-snippet__line-index code-snippet__js\"><li></li></ul>于是在同步文章的时候也进行一些替换：//移除公众号代码片段序号\r\nlet content=content.replace(<ul class=\"code-snippet__line-index code-snippet__js\".*?<\\/ul>/g,'')目前解析过程中还有两个问题不太友好，后期需要尝试解决：第一个是部分图片依旧不会展示，原因已经定位到， img 标签之外嵌套了以下 span 标签之后，图片就不会展示「使用新媒体管家进行排版时会出现」<span style=\"color:rgba(0, 0, 0, 0);\">\r\n<span style=\"line-height: inherit;margin-right: auto;margin-left: auto;border-radius: 4px;\">另一个是部分解析出来的代码片段没有换行「使用 Md2All 进行样式转换的文章」总结但愿小程序后期官方出个比较全面的富文本组件吧，这样可以少绕很多弯路去实现简单的功能。"}
{"tittle": "小程序的一些小知识总结 ", "author": "Rolan", "pub_time": "2019-5-9 00:51", "content": "小程序很多方法都是异步的原因刚接触小程序的时候，发现很多微信提供的api都是异步的，如路由跳转，设置和读取缓存，还有获取节点信息等微信的api，都是异步的，需要传入回调函数才能获得结果，在我们正常的前端开发中，这些都不是异步的，当时很奇怪为什么是这样的，最近看了微信的一个开发教程之后，总算是明白了。 微信小程序开发教程小程序的底层架构是双线程模式，逻辑层和渲染层是分开的两个线程，渲染层指的就是渲染wxml和wxss，逻辑层指的是执行js文件，两个线程分开运行，通过微信客户端进行通信，调用微信的api的时候其实就是执行js的线程和微信客户端通信下图是微信官方文档里渲染页面的一个流程图注意事项：上述说了，小程序的渲染层和逻辑层是分开的两个线程，执行js逻辑的只有一个线程，所以在js里声明了的函数，只要有调用，就算页面卸载了，最终都会执行，所以要注意的是，一些interval，或者一些注册的其他函数，如果不想在页面离开后继续执行的话，在页面卸载的时候要注销掉。发布和订阅模式先补充一个知识点：在小程序的appjs的onLaunch里，给全局变量wx添加的属性，是全局有效的，能在其他页面中调用，比如：onLaunch: function () {\r\n    wx.aaa = '123456'; \r\n    wx.bbb = function () { console.log('541521') }\r\n}\r\n\r\n\r\nonLoad: function () {\r\n    console.log(wx.aaa);\r\n    wx.bbb();\r\n}之前对发布和订阅一直没什么概念，但是多学点东西总没坏处，近期自己花了点时间专门看了一下，大概明白了一点。订阅：订阅就是在某个地方注册一个自定义的事件，供其他地方调用发布：触发已经订阅的函数下面是我写的一个方法，可能会有一些bug，但是目前没有发现，要是有问题的话欢迎交流一下var MyEvent = (function () {\r\n  // 声明方法\r\n  var pub, sub, remove;\r\n\r\n  // 订阅缓存记录\r\n  var subCache = {};\r\n  // 发布缓存记录\r\n  var pubCache = {};\r\n  // 参数缓存\r\n  var paramCache = {};\r\n\r\n  // 订阅事件\r\n  sub = function (key, fn) {\r\n    if (!subCache[key]) {\r\n      subCache[key] = [];\r\n    }\r\n    // 添加到订阅缓存中\r\n    subCache[key].push(fn);\r\n    // 如果有发布记录，则直接执行函数\r\n    if (pubCache[key]) {\r\n      if (paramCache[key]) {\r\n        fn.apply(null, paramCache[key]);\r\n      } else {\r\n        fn.apply(null);\r\n      }\r\n      pubCache[key] = undefined;\r\n    }\r\n  };\r\n  pub = function () {\r\n    var key = Array.prototype.shift.call(arguments);\r\n    var fns = subCache[key];\r\n    // 没有订阅过，则将参数缓存，待订阅的时候直接执行\r\n    if (!fns || fns.length === 0) {\r\n      pubCache[key] = true;\r\n      paramCache[key] = Array.prototype.slice.call(arguments, 0);\r\n      return;\r\n    }\r\n    // 有订阅记录，则直接执行\r\n    for (let fn of fns) {\r\n      fn.apply(null, arguments);\r\n    }\r\n  };\r\n  remove = function (key) {\r\n    // 把所有的缓存全部清除\r\n    subCache[key] = undefined;\r\n    pubCache[key] = undefined;\r\n    paramCache[key] = undefined;\r\n  };\r\n  return {\r\n    pub: pub,\r\n    sub: sub,\r\n    remove: remove\r\n  };\r\n})();\r\n\r\nmodule.exports = MyEvent;使用方法如下：在appjs里引入MyEvent，并挂载在wx对象上App({\r\n  onLaunch: function () {\r\n    const MyEvent = require('myEvent的路径');\r\n    wx.myEvent = MyEvent;\r\n  }\r\n})在其中页面页面1的onShow里订阅test1事件，发布test2事件onLoad: function(){\r\n    wx.myEvent.sub('test1', function () {\r\n        console.log('test1');\r\n    });\r\n},\r\nonShow: function () {\r\n    wx.myEvent.pub('test2', 'test2' + new Date().getTime());\r\n}在页面2的onLoad事件里，发布test1事件，订阅test2事件onLoad: function(options) {\r\n    wx.myEvent.pub('test1');\r\n    wx.myEvent.sub('test2', function(a){\r\n      console.log(a);\r\n    });\r\n}一. 在页面1的时候，执行了订阅test1事件，发布了test2事件，但是test1没有发布，订阅的事件不会执行，test2事件没有订阅，也不会执行。二. 从页面1跳转到页面2，发布了test1事件，直接执行之前已经注册好的test1事件，订阅test2事件，因为有test2的发布事件，订阅之后直接执行，结果是打印一次test1，打印一次test2。三. 从页面2返回到页面1，执行onShow事件，再次发布test2事件，打印一次test2四. 从页面1到页面2，发布了test1事件，事件test2重复订阅了，订阅了两次，打印一次test1。五. 从页面2返回页面1，发布test2，因为test2事件订阅了两次，所以打印了两次test2，所以要注意在不需要的地方把事件注销。在页面2的onUnload事件里把事件test2注销掉，在从页面2回到页面1的时候，事件test2已经注销了，不会再执行。onUnload: function() {\r\n    wx.myEvent.remove('test2');\r\n}原理和用法说明：原理：全局只有一个wx对象，将myEvent挂载在wx上，所以全局也只有一个wx.myEvent对象，myEvent里用到了闭包，订阅的函数和参数都有保存在内存里，所以能实现订阅和发布的功能。目前事件订阅是用的数组存储，可实现同一个事件订阅多次，如果不需要的话可自行修改成只能订阅一次的方法。用法：一般用于跨页面的操作，比如在某个页面订阅某个事件，在另一份页面执行了某项操作之后，发布该事件，会直接执行订阅的事件，实现页面间的一些数据传递。还有也可用于异步请求，先订阅某个事件，异步请求数据，请求数据回来之后，再发布。待补充......"}
{"tittle": "微信小程序开发之从“跳伞”到“吃鸡” ", "author": "Rolan", "pub_time": "2018-7-26 00:28", "content": "写在前边微信小程序随着官方开放越多越多的接口，也是变的越来越火了，越来越多的企业已经开始布局小程序生态。所以，对于我们开发者来说，掌握小程序开发显得分外重要。如果点亮了该技能，那么离升职加薪赢取白富美的日子就又近了一步啦！关于我笔者算是一个野生的程序猿吧，没有什么大厂经验，搞开发就是一个字，干！从不来虚的。因此，随性的性格造就了我全栈（一窍不通）的本事，做项目那就是一把抓，前后端全包，什么前后端撕逼的问题统统没有了，哈哈哈（想想心里还有点小激动）。不过本文笔者只重点分享小程序开发相关的东西，想了解后端的话，可以坐等我下一次的分享哈哈哈（可能会遥遥无期）。准备工作话不多说，进入正题。现在开始分享我是怎么开发完一款小程序的。小程序的官方文档其实写的是很详细很清晰的，相比微信公众号的开发文档来说真的是非常非常的良心，所以开发前浏览一遍开发文档非常关键。下边我分享一下其他准备工作。1. 开发工具工欲善其事，必先利其器，首选的就是把开发环境给弄好咯，我推荐如下：开发工具官方微信开发者工具visio studio code调试工具官方微信开发者工具当然开发工具什么的只要自己习惯就好，我的推荐只是参考。笔者最后习惯是直接在官方的开发者工具上编辑加调试。2. 小程序配置这块的内容官方文档都有详细的教程，我就不多补充啦。总体来说就是需要去申请一个开发者账号，然后配置小程序的基本信息，比较值得重点说的就是小程序api的配置，官方要求必须是https。说到这里，如果读者你的api接口已经了https可以跳过了，如果不是，然后你也像笔者一样是全栈开发，那么笔者将告诉你如何快速让接口踏上https的航班。是的，没错， 就是它！Certbot在官网上选好http服务器和linux系统后，按照命令一个一个敲，就ok了，简直不要太简单。哈哈哈，至于想深入了解这个东东的话，可以去了解下Let's Encrypt开发总算可以正式的开始撸功能了！因为考虑到现在程序猿找对象是真的太难了，所以笔者撸的小程序是一个脱单交友的小程序（单身汪的福音哦），小程序页面也不多，核心就是让用户填写个人信息然后展示出来。是的，就是这么简单！授权登录小程序的授权登录其实可以看作是两件事情，授权和登录，这两者是可以单独分开处理的（个人观点，允许反驳）。授权对于授权，其实官方已经有讲到，就是换成微信内的授权询问，就是如下这个东西。这个微信授权的询问弹窗之前的版本中只要调用获取用户信息的api，是会自动弹出的，现在小程序做了调整需要自行通过按钮触发，所以这个很蛋疼。那么需要怎么去设计呢，这里也有两个方案，一个是做个单独的页面，另一个方案是做弹窗。个人建议是选方案一，因为这样可以把授权逻辑从页面逻辑里独立出来，方便所有页面渲染前调用。具体coding如下：在app.js中，判断是否已经授权，如果未授权则跳转到授权页面App({\r\n  onLaunch: function () {\r\n    ...\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },在'pages/auth/index.wxml'页面中，使用button做授权按钮<button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">微信账号授权登录</button>'pages/auth/index.js'中定义绑定的回调方法，重新跳转回上一页Page({\r\n  ...\r\n  // 点击授权后跳回首页\r\n  bindGetUserInfo (e) {\r\n    wx.reLaunch({ url: '../index/index' })\r\n    // 用户已经同意小程序使用获取用户信息功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n  }\r\n})\r\n这样，一个授权逻辑就完成了。登录登录的目录其实是和后端交互，需要在服务器端存储当前用户的标识，以便用户下一次登录时服务器知道是谁登录了。做过微信公众号开发的朋友应该都知道，能承担这个作用的角色就是open_id了，所以要实现登录的话，其实就是需要获取当前用户的open_id，官方文档中是这么介绍的：1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。所以完成登录的前提就是需要后端提供一个接口，咱们把code传给后端就行了，剩下的工作就是后端去完成啦App({\r\n  onLaunch: function () {\r\n    // 授权判断\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },\r\n  // 登录\r\n  wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        if (res.code) {\r\n          api.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n              wx.setStorageSync('access_token', res.access_token)\r\n          }).catch(error=>{\r\n            console.log(error)\r\n          })\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })这里需要多提的一点是关于会话维持的方案，就是如何让服务器端知道访问接口的是谁。笔者提供两个办法：通过wx.request()在header中强行组装cookie字符串，来实现传统浏览器上用cookie维持会话的效果使用access_token的方式，比如jwt笔者选择的是第二种，通过后端的登录接口返回token，然后将token存入Storage，然后在发起请求的时候将token封装到http请求体中。 两种方案都可行，读者们可根据自己情况自行实现。 由于wx.request()方法发起请求比较麻烦，还需要处理会话逻辑，所以建议读者们还是进行一次封装，下边贴上笔者的代码：在utils文件夹中创建request.js文件const domain = \"https://cdx.tyhub.com\"\r\nfunction GET(url, params) {\r\n  return request('GET', url, params)\r\n}\r\nfunction POST(url, params) {\r\n  return request('POST', url, params)\r\n}\r\nfunction request(method, url, params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: domain + url,\r\n      data: params,\r\n      method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': 'bearer' + ' ' + wx.getStorageSync('access_token'),\r\n      },\r\n      success(res) {\r\n        if (res.data.code === 100) {\r\n          let resData = res.data.data\r\n          if (!resData) {\r\n            resData = ''\r\n          }\r\n          resolve(resData)\r\n        } else {\r\n          let err = {\r\n            code: res.data.code,\r\n            msg: res.data.msg\r\n          }\r\n          reject(err)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  get: GET,\r\n  post: POST\r\n}使用const api = require('../../utils/request')\r\n...\r\napi.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n     wx.setStorageSync('access_token', res.access_token)\r\n }).catch(error=>{\r\n   console.log(error)\r\n })至此，登录逻辑便已完成，是不是觉得小程序开发也不过如此呢？由于篇幅有限，今天就分享到这啦，后续我将继续和看官们一起探究以下小程序开发的话题图片上传表单提交级联选择器的实现如何使用iconfont图标微信支付模板消息....欢迎笔者持续关注，也欢迎笔者私信告知我其他疑问，我尽量都一一分享，知无不言，言无不尽。不是结束的结语打波小小的广告，个人开发的找对象小程序“佛系处对象”已经顺利上线，欢迎笔者看官们扫码体验，如果脱单了记得通知我哟！最后祝大家在事业和爱情的“战场中都能脱颖而出，顺利吃鸡！"}
{"tittle": "适用于小程序的 ES6 ", "author": "Rolan", "pub_time": "2019-4-23 00:56", "content": "JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。ES6新增了完全支持UTF-16的方法codePointAt()，该方法接受编码单元的位置而非字符位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值var text = \"a\" ;\r\n\r\nconsole.log(text.charCodeAt(0)); // 55362\r\nconsole.log(text.charCodeAt(1)); // 57271\r\nconsole.log(text.charCodeAt(2)); // 97\r\n\r\nconsole.log(text.codePointAt(0)); // 134071\r\nconsole.log(text.codePointAt(1)); // 57271\r\nconsole.log(text.codePointAt(2)); // 97二、includes1. indexOf用来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素。2. Array.includes()函数判断是否包含某一元素，返回 true / false，不能定位元素，但是能判断 NaN。const arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', NaN]\r\nconsole.log('%s', arr1.indexOf(NaN)) // -1\r\nconsole.log(arr1.includes('c')) // true\r\nconsole.log(arr1.includes('z')) // false\r\nconsole.log(arr1.includes(NaN))  // true复制代码三、startsWith1. 确定字符串是否以指定字符串的字符开头，返回 true/false。注意：区分大小写！2. 接受两个参数：  第一个参数，要在此字符串开头搜索的字符；  第二个参数是指定从字符串开始的位置，默认从零开始 四、endsWith1. 从字符串的末尾开始查找五、repeat1. 返回一个新字符串，表示将原字符串重复n次let str1='a';\r\nlet str2=str1.repeat(3);\r\nconsole.log(str2)//aaa复制代码六、String.fromCodePoint七、copyWithin1. 用于操作当前数组自身，用来把某些位置的元素复制并覆盖到其他位置上去。2. 该函数有三个参数：  target：目的起始位置；  start：复制源的起始位置，可以省略，可以是负数；  end：复制源的结束位置，可以省略，可以是负数，实际结束位置是end-1。3. const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr1.copyWithin(1, 3, 6)\r\nconsole.log('%s', JSON.stringify(arr1)) // [1,4,5,6,5,6,7,8,9,10,11]\r\n复制代码目标的位置不够的，能覆盖多少就覆盖多少const arr2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr2.copyWithin(3)\r\nconsole.log('%s', JSON.stringify(arr2)) // [1,2,3,1,2,3,4,5,6,7,8]复制代码start和end都可以是负数，负数表示从右边数过来第几个const arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\narr3.copyWithin(3, -3, -2)\r\nconsole.log(JSON.stringify(arr3)) // [1,2,3,9,5,6,7,8,9,10,11]复制代码八、find1. 查找目标元素，找到就返回该元素，找不到返回undefinedconst arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\r\nvar ret1 = arr1.find((value, index, arr) => { \r\nreturn value > 4\r\n})\r\nvar ret2 = arr1.find((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret1) // 5\r\nconsole.log('%s', ret2) // undefined复制代码九、findIndex1. 查找目标元素，找到就返回元素的位置，找不到就返回-1var ret3 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 4\r\n}) \r\nvar ret4 = arr1.findIndex((value, index, arr) => { \r\nreturn value > 14\r\n})\r\nconsole.log('%s', ret3) // 4\r\nconsole.log('%s', ret4) // -1复制代码十、fill1. 使用制定的元素填充数组2. 参数：  value：填充值。  start：填充起始位置，可以省略。  end：填充结束位置，可以省略，实际结束位置是end-1。const arr1 = [1, 2, 3, 4, 5]\r\narr1.fill(7)\r\nconsole.log(arr1) // [7, 7, 7, 7, 7]复制代码十一、entries()，keys()和values() —— 用于遍历数组1. 区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历for (let index of ['a', 'b'].keys()) {\r\n console.log(index) // 0 1\r\n}复制代码十二、Array.from1. 将对象转换成数组2. 条件：  1）部署了Iterator接口的对象，比如：Set，Map，Array  2）类数组对象，就是一个对象必须有length属性，没有length，转出来的就是空数组。转换map转换set转换字符串Array.from('hello world') // [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]复制代码Array.from('\\u767d\\u8272\\u7684\\u6d77') // [\"白\", \"色\", \"的\", \"海\"]复制代码类数组对象Array.from({\r\n  0: '0',\r\n  1: '1',\r\n  3: '3',\r\n  length:4\r\n}) \r\n// [\"0\", \"1\", undefined, \"3\"]复制代码Array.from({\r\n  0: 0,\r\n  1: 1\r\n})\r\n// []复制代码3. 参数： 1）被转换的的对象。 2）map函数。3）map函数中this指向的对象。let diObj = {\r\n  handle: function(n){\r\n    return n + 2\r\n  }\r\n}\r\nArray.from(\r\n  [1, 2, 3, 4, 5], \r\n  function (x){\r\n    return this.handle(x)\r\n  }, \r\n  diObj\r\n) // [3, 4, 5, 6, 7]复制代码十三、Array.of1. new Array()构造数组的时候，是有二意性的  构造时，传一个参数，表示生成多大的数组。  构造时，传多个参数，每个参数都是数组的一个元素。2.  将一个或多个值转换成数组 === new Array() 传多个参数 的情况"}
{"tittle": "【开发经验】iOS不使用微信sdk，直接打开小程序 ", "author": "Rolan", "pub_time": "2019-4-16 00:25", "content": "直接贴代码iOS审核不让有支付代码，所以只使用轻度功能的话，可以不使用微信SDK。使用前需要先去微信开放平台绑定。我的封装/**\r\n *  开发前需要到微信开放平台把App绑定小程序，然后在小程序的管理员微信上点击同意绑定，就可以转跳了\r\n *  字段解释：\r\n *  @appid：小程序appid\r\n *  @username：‘gh’开头的小程序公用id\r\n *  @path：小程序需要打开页面的路径\r\n *  @type：0是正式版，1是开发版，2是体验版\r\n **/\r\n-(void)jumpToWechatMiniProgram:(NSString *)appid ghId:(NSString *)username path:(NSString *)path type:(NSString *)miniProgramtype{\r\n    NSString *mPath = [path stringByReplacingOccurrencesOfString:@\"/\" withString:@\"%2F\"];\r\n    NSString *url = [NSString stringWithFormat:@\"weixin://app/%@/jumpWxa/?userName=%@&path=%@&miniProgramType=%@&extMsg=\",appid,username,mPath,miniProgramtype];\r\n    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]options:@{} completionHandler:^(BOOL success) {\r\n        NSLog(@\"跳转成功\");\r\n    }];\r\n}调用-(IBAction)jumpWithUrl:(id)sender{\r\n    [self jumpToWechatMiniProgram:@\"wx8888888888888\" ghId:@\"gh_88888888888\" path:@\"pages/index/index?session=自己定的参数\" type:@\"2\"];\r\n}Scheme白名单如果是真机测试记得在info.plist添加白名单<key>LSApplicationQueriesSchemes</key>\r\n    <array>\r\n        <string>mqzone</string>\r\n        <string>sinaweibo</string>\r\n        <string>mqqwpa</string>\r\n        <string>mqqbrowser</string>\r\n        <string>wtloginmqq2</string>\r\n        <string>weixin</string>\r\n        <string>wechat</string>\r\n    </array>获取微信sdk的其他功能iOS中，app互相转跳走的都是openUrl这个接口，通过scheme就可以转跳到目标程序，但是scheme是不审核的，可以随意指定，所以我们可以通过写一个假微信（scheme是weixin），来拦截微信SDK的启动请求，从而获取到对应的启动字符串，然后自己拼接字符串即可。伪造微信在info.plist里添加(注意缩进不要弄错了，最好在模拟器上试，如果安装了微信，是不会跳到我们的假微信里的。)：<key>CFBundleURLTypes</key>\r\n    <array>\r\n        <dict>\r\n            <key>CFBundleURLSchemes</key>\r\n            <array>\r\n                <string>weixin</string>\r\n            </array>\r\n            <key>CFBundleURLName</key>\r\n            <string>1111</string>\r\n        </dict>\r\n    </array>看不到源码页面的话，右键info.plist，选择Open As -> Source Code就能看到了，改完了切回Property List模式，不报错就说明格式是对的。获取转跳参数在appDelegate.m里增加:// 这方法显示已经废弃了，但是只是获取参数还是可以的\r\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url\r\n  sourceApplication:(NSString *)sourceApplication annotation:(id)annotation{\r\n    //显示截取的urlscheme\r\n    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@\"接收到的urlScheme\" message:url.absoluteString delegate:nil cancelButtonTitle:nil otherButtonTitles:@\"确定\", nil];\r\n    [alert show];\r\n//    复制到剪贴板\r\n    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];\r\n    pasteboard.string = url.absoluteString;\r\n    \r\n    return YES;\r\n}然后就能看到弹窗里的urlscheme就可以了，只要拼接出一个一样的urlscheme，就可以启用微信SDK同样的功能。"}
{"tittle": "小程序组件化开发，编写高可维护性的代码 ", "author": "Rolan", "pub_time": "2019-4-16 00:30", "content": "前言在如今mvvm框架大行其道的时代，页面组件化开发已经是每位前端开发人员必备的基本素养。事实上不仅仅是web前端领域，甚至是安卓客户端开发也使用上了mvvm的思想理念。那么怎样去以组件化的方式去思考问题呢？在小程序中怎样使用组件才是最佳的姿势呢？ 有必要组件化吗 按照JQuery时代的方式，将设计图从上到下一股脑儿用html+css代码去实现，并且把这些代码全塞进一个html文件中不是很好吗？确实，这样的代码“写时一时爽，维护两行泪。”当需求变更时，我们不得不满页面的找相关代码然后去修改。更无奈的是所有的不同模块的js部分也都耦合到一个js文件中，修改起来十分吃力。为了编写高内聚低耦合的高可维护性的代码，模块化是有效且可行的。模块化的思想已经渗透了整个计算机科学领域，无论是操作系统还是大型应用软件。模块化大致有以下几个优点：易扩展性：扩展只需要添加新的模块或者是修改某个已有的模块。高内聚：相关性强的代码被划分到一个模块，大大提高代码的内聚性。bug易于排查：在出现bug时我们只需要根据bug的表象却推断可能是哪个模块出现问题，锁定模块后在模块中找出问题根源，而不需要在整个系统中找一个很小的bug。便于分工协作：软件工程就如同盖楼房，考验的是分工协作。模块化可以将一个模块分配给一个人或一个小团队负责。模块之间可以同时开发而且互不影响。组件化开发就是前端中很好的模块化思想的体现。 怎样将组件化思想贯彻下去将拿到的设计图按照不同的功能模块划分出不同的组件，组件之间可以有嵌套或者并列关系。组件不论大小，小到一个按钮，大到一个页面都可以看成一个个组件。不要觉得小东西就没必要写成组件，因为一个组件的功能越简单，那么使用它的时候也就越容易，而且能够使用到它的场景将越多。所以如果你写出了一个功能十分全面且复杂的组件，不要高兴，因为它也许只会被使用一次。这个时候就需要把功能复杂的组件拆分成更小功能的组件，而这个功能复杂的组件将使用这些功能更小的组件去实现。组件中不要包含业务逻辑代码。例如：你想实现一个搜索框组件，用户输入关键字点击搜索就可以搜索到结果。这个时候你可能顺其自然的把通过关键字调用接口然后从接口中拿到搜索结果的逻辑代码也写到组件中了。除非在这个项目中所有的搜索框都会调用这个接口并且你不打算把这个组件运用到其它项目中。否则这部分逻辑代码不应该写到组件中。组件一但编写完成并且被运用了无数次之后，请不要随意去修改组件了，因为这样会影响到所有使用了改组件的地方。除非需求变更，整个项目中的搜索框都需要改变样式，这个时候就可以发挥组件的威力了，修改一次组件即可。但修改时不要破坏组件的扩展性。在编写组件是需要充分考虑扩展性，把动态属性暴露出去。一个没有扩展性的组件将会变得没有意义，扩展性越强意味着该组件的使用几率越大，价值也就越大。还是以搜索框为例，我们可以把搜索框的搜索按钮点击事件暴露出来，然后在使用搜索组件的地方去实现这个点击事件的逻辑。这是react的官方教程文档。你可以从中得到很多组件化开发的启发。 在项目中使用组件在团队项目中，采用组件化开发请不要忽视文档的重要性。如果你开发出了一个组件而没有为该组件配上使用说明文档，那么这个组件的价值将降低一半。因为使用者在使用它时必须查看组件的源代码理清它的基本思路才能很好的使用，这样跟他自己重写一遍花费的时间和精力成本是相当的。即使是你自己使用，也许数月后你也会变得十分陌生。久而久之这个组件将失去它存在的意义。请像后台开发人员对待api文档一样对待组件说明文档。小程序的详细组件开发教程请查看我的这篇博客"}
